<!DOCTYPE html>
<html lang="en">

<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
	<meta name="keywords" content="How_run_business_pod_in_edge_scenarios" />
	<meta name="description" content="How_run_business_pod_in_edge_scenarios" />
	<!-- 网页标签标题 -->
	<title>How_run_business_pod_in_edge_scenarios</title>
	<link rel="shortcut icon" href="/img/docsite.ico"/>
	<link rel="stylesheet" href="/build/blogDetail.css" />
</head>
<body>
	<div id="root"><div class="blog-detail-page" data-reactroot=""><header class="header-container header-container-normal"><div class="header-body"><a href="/zh-cn/index.html"><img class="logo" src="/img/OpenYurt.png"/></a><div class="search search-normal"><span class="icon-search"></span></div><span class="language-switch language-switch-normal">En</span><div class="header-menu"><img class="header-menu-toggle" src="/img/system/menu_gray.png"/><ul><li class="menu-item menu-item-normal"><a href="/zh-cn/index.html" target="_self">首页</a></li><li class="menu-item menu-item-normal"><a href="/zh-cn/docs/developer-guide.html" target="_self">文档</a></li><li class="menu-item menu-item-normal menu-item-normal-active"><a href="/zh-cn/blog/index.html" target="_self">博客</a></li></ul></div></div></header><section class="blog-content markdown-body"><h1>OpenYurt：在边缘场景无缝运行使用InClusterConfig的业务Pod</h1>
<p><strong>2021-10-15</strong>      <strong>新胜</strong></p>
<h3>1.背景介绍</h3>
<p>OpenYurt是业界首个非侵入的边缘计算云原生开源项目，通过边缘自治，云边协同，边缘单元化，边缘流量闭环等能力为用户提供云边一体化的使用体验。不少用户在使用OpenYurt的时候，经常需要把存量的使用InClusterConfig访问kube-apiserver的Pod通过OpenYurt迁移到边缘环境中。如下图所示：</p>
<p><img src="../../img/InCluster1.png" alt=""></p>
<p>在OpenYurt集群中，提供了使用InClusterConfig的业务Pod零修改就可以运行在边缘环境的能力。</p>
<h3>2.面临挑战</h3>
<p>使用InClusterConfig的业务Pod在边缘环境中运行，需要解决如下问题：</p>
<ul>
<li>
<p>问题一：Pod通过InClusterConfig地址访问kube-apiserver，节点上默认网络规则（iptables/ipvs）将会把请求转发到kube-apiserver的PodIP，同时云端与边缘位于不同网络平面，边缘是无法访问到云端的PodIP。所以边缘业务Pod无法通过InClusterConfig访问到kube-apiserver。</p>
<p><img src="../../img/Incluster2.png" alt="Incluster2"></p>
</li>
<li>
<p>问题二：在解决问题一后，如果云边网络断开时业务Pod容器出现重启等状况，边缘Pod将无法从kube-apiserver获取到业务配置，这会影响到业务Pod的重启运行。</p>
</li>
</ul>
<h3>3.解决方案</h3>
<p>从上述问题可以看出，我们需要无感知的调整边缘pod的访问地址，同时需要在边缘环境中缓存业务配置，保证云边断网时也可以利用边缘缓存业务配置，保证云边断网时也可以利用边缘缓存来获取业务Pod的配置信息。具体解决方案如下；</p>
<h5>3.1边缘Pod访问的云端endpoint优化</h5>
<ul>
<li>
<p>Pod通过InClusterConfig访问kube-apiserver，源码如下：</p>
<pre><code class="language-go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">InClusterConfig</span><span class="hljs-params">()</span> <span class="hljs-params">(*Config, error)</span></span> {
<span class="hljs-keyword">const</span> (
    tokenFile  = <span class="hljs-string">"/var/run/secrets/kubernetes.io/serviceaccount/token"</span>
    rootCAFile = <span class="hljs-string">"/var/run/secrets/kubernetes.io/serviceaccount/ca.crt"</span>
<span class="hljs-comment">// 通过Kuberentes service对应的环境变量来获取访问地址</span>
host, port := os.Getenv(<span class="hljs-string">"KUBERNETES_SERVICE_HOST"</span>), os.Getenv(<span class="hljs-string">"KUBERNETES_SERVICE_PORT"</span>)
<span class="hljs-keyword">if</span> <span class="hljs-built_in">len</span>(host) == <span class="hljs-number">0</span> || <span class="hljs-built_in">len</span>(port) == <span class="hljs-number">0</span> {
    <span class="hljs-keyword">return</span> <span class="hljs-literal">nil</span>, ErrNotInCluster
}

<span class="hljs-comment">// skip some code...</span>

<span class="hljs-keyword">return</span> &amp;Config{
    Host:            <span class="hljs-string">"https://"</span> + net.JoinHostPort(host, port),
    TLSClientConfig: tlsClientConfig,
    BearerToken:     <span class="hljs-keyword">string</span>(token),
    BearerTokenFile: tokenFile,
}, <span class="hljs-literal">nil</span>
}
</code></pre>
</li>
<li>
<p>因此想无感知调整边缘Pod访问的云端endpoint，只需要无侵入修改Pod的KUBERNETES_SERVICE_HOST和KUBERNETE_SERVICE_PORT两个环境变量或者修改kubernetes service地址。解决方案如下：</p>
<ul>
<li>
<p>解决方案一：增加一个admission controller在边缘Pod创建时把kube-apiserver的公网地址自动注入到Pod的环境变量KUBERNETES_SERVICE_HOST和KUBERNETE_SERVICE_PORT</p>
</li>
<li>
<p>解决方案二：边缘数据过滤框架中增加一个fillter yurthub的边缘数据过滤框架类似于admission controller ,专门用于边缘场景下在边缘应用无感知的状态下，无侵入的修改或者过滤云端返回的数据。目前支持的过滤器有：Masterservice，servicetopology，discardcloudservice等</p>
</li>
<li>
<p>解决方案对比：</p>
<table>
<thead>
<tr>
<th style="text-align:center"></th>
<th style="text-align:center">解决方案一</th>
<th style="text-align:center">解决方案二</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">实现方案</td>
<td style="text-align:center">增加一个admission controller</td>
<td style="text-align:center">边缘数据过滤框架中增加一个filter</td>
</tr>
<tr>
<td style="text-align:center">复杂度</td>
<td style="text-align:center">高（需要区别Pod运行在边缘还是云端）</td>
<td style="text-align:center">低</td>
</tr>
<tr>
<td style="text-align:center">显示修改数据</td>
<td style="text-align:center">Pod中增加环境变量配置</td>
<td style="text-align:center">无</td>
</tr>
</tbody>
</table>
</li>
</ul>
</li>
</ul>
<p>综合实现复杂度，非侵入等设计理念，在OpenYurt中我们选择了解决方案二。如下图所示：</p>
<p><img src="../../img/InCluster3.png" alt=""></p>
<h5>3.2业务Pod的边缘自治</h5>
<p>在云边网络断开状态下，业务Pod重启时，将无法从云端kube-apiserver获取到业务配置信息，因此需要在边缘本地缓存Pod的业务数据。</p>
<p><img src="../../img/InCluster4.png" alt=""></p>
<p>说明1：业务Pod通过yurthub访问kube-apiserver，也意味着[3.1 边缘Pod访问的云端endpoint优化]章节中提到的KUBERNETES_SERVICE_HOST和KUBERNETE_SERVICE_PORT环境变量被修改为yurthub https endpoint(169.254.2.1:10268)。</p>
<p>说明2：如果业务Pod的大量list/watch操作导致大量本地cache，可能会造成本地磁盘压力，因此yurthub对业务Pod的缓存能力默认是关闭的，用户可以通过yurt-hub-cfg configmap的cache_agents字段中增加User-Agent信息来打开对应Pod的数据缓存。例如：</p>
<pre><code class="language-go">apiVersion: v1
kind: ConfigMap
metadata:
  name: yurt-hub-cfg
  namespace: kube-system
data:
  # 缓存边缘ingress-controller pod访问kube-apiserver的数据
  cache_agents: <span class="hljs-string">"ingress-controller"</span>
</code></pre>
<h3>4.总结</h3>
<ul>
<li>
<p>如果存量Pod无需访问kube-apiserver或者InClusterConfig访问kube-apiserver，这些类型Pod可以零修改运行到OpenYurt集群的边缘环境上。通过其他方式访问kube-apiserver的业务Pod目前无法保证零修改运行到边缘环境。</p>
</li>
<li>
<p>边缘业务Pod是否正常访问kube-apiserver，首先可以查看业务pod的环境变量是否正常：</p>
<p>KUBERNETES_SERVICE_HOST=127.0.0.1或者169.254.2.1，KUBERNETES_SERVICE_PORT=10268。然后可以查看yurthub组件的日志是否有业务Pod相关的请求日志。当然也可以查询业务Pod的日志是否正常。最后可以确认/etc/kubernetes/cache目录是否有相关组件的缓存数据，如果没有可以再确认kube-system/yurt-hub-cfg configmap是否已经配置。</p>
</li>
<li>
<p>使用InClusterConfig的Pod零修改运行到边缘环境的能力，整体实现由yurthub组件承载，没有给OpenYurt架构增加额外的负担，同时用户在使用过程中对该能力也基本无感知，对原生业务Pod无侵入。</p>
</li>
</ul>
<h3>参考链接：</h3>
<p>1.<a href="https://kubernetes.io/docs/tasks/access-application-cluster/access-cluster/#accessing-the-api-from-a-pod">Accessing the API from a Pod</a></p>
<p>2.<a href="https://github.com/openyurtio/openyurt/blob/master/docs/proposals/20210720-data-filtering-framework.md">data filtering framework on the edge</a></p>
<p>3.<a href="https://mp.weixin.qq.com/s/4BLfvMJJA623ZwRSgUE69A">深度解读OpenYurt：边缘自治能力设计解析</a></p>
</section><footer class="footer-container"><div class="cloud-native"><div class="container"><img src="https://d33wubrfki0l68.cloudfront.net/ea0d91fac8683c38ea9a1fb8a4e9914627ac6aae/8efa9/img/logos/cloud-native-computing.svg"/><p>We are a <a href="https://www.cncf.io">Cloud Native Computing Foundation</a> sandbox project.</p></div></div><div class="copyright"><span>Copyright © 2021 The OpenYurt Authors. All rights reserved. The Linux Foundation has registered trademarks and uses trademarks. For a list of trademarks of The Linux Foundation, please see our Trademark Usage page: <a href="https://www.linuxfoundation.org/trademark-usage">https://www.linuxfoundation.org/trademark-usage</a></span></div></footer></div></div>
	<script src="https://f.alicdn.com/react/15.4.1/react-with-addons.min.js"></script>
	<script src="https://f.alicdn.com/react/15.4.1/react-dom.min.js"></script>
	<script>
		window.rootPath = '';
  </script>
	<script src="/build/blogDetail.js"></script>
</body>
</html>