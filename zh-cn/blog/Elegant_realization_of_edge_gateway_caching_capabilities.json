{
  "filename": "Elegant_realization_of_edge_gateway_caching_capabilities.md",
  "__html": "<h1>边缘网关缓存能力的优雅实现</h1>\n<p>2021-03-29  <strong>阿里巴巴云原生</strong>\n<img src=\"../img/blog_img/OpenYurt.png\" alt=\"image\"></p>\n<h2>OpenYurt如何解决边缘自治问题</h2>\n<p>想要实现将 Kubernetes 系统延展到边缘计算场景，那么边缘节点将通过公网和云端连接，网络连接有很大不可控因素，可能带来边缘业务运行的不稳定因素，这是云原生和边缘计算融合的主要难点之一。</p>\n<p>解决这个问题，需要使边缘侧具有自治能力，即当云边网络断开或者连接不稳定时，确保边缘业务可以持续运行。在 OpenYurt 中，该能力由 yurt-controller-manager 和 YurtHub 组件提供。</p>\n<h3>1）Yurthub架构</h3>\n<p>在之前的文章中，我们详细介绍了YurtHub 组件的能力。其架构图如下：\n<img src=\"../img/blog_img/yurthub.png\" alt=\"image\">\nYurtHub是一个带有数据缓存功能的“透明网关”，和云端网络断连状态下，如果节点或者组件重启，各个组件（kubelet/kube-proxy 等）将从 YurtHub 中获取到业务容器相关数据，有效解决边缘自治的问题。这也意味着我们需要实现一个轻量的带数据缓存能力的反向代理。</p>\n<h3>2）第一想法</h3>\n<p>实现一个缓存数据的反向代理，第一想法就是从 response.Body 中读取数据，然后分别返回给请求 client 和本地的 Cache 模块。伪代码如下:</p>\n<pre><code>func HandleResponse(rw http.ResponseWriter, resp *http.Response) {\n        bodyBytes, _ := ioutil.ReadAll(resp.Body)\n        go func() {\n                // cache response on local disk\n                cacher.Write(bodyBytes)\n        }\n\n        // client reads data from response\n        rw.Write(bodyBytes)\n}\n</code></pre>\n<p>当深入思考后，在 Kubernetes 系统中，上述实现会引发下面的问题：</p>\n<ul>\n<li>\n<p>问题 1：流式数据需要如何处理(如: K8s 中的 watch 请求)，意味 ioutil.ReadAll() 一次调用无法返回所有数据。即如何可以返回流数据同时又缓存流数据。</p>\n</li>\n<li>\n<p>问题 2：同时在本地缓存数据前，有可能需要对传入的 byte slice 数据先进行清洗处理。这意味着需要修改 byte slice，或者先备份 byte slice 再处理。这样会造成内存的大量消耗，同时针对流式数据，到底申请多大的 slice 也不好处理。</p>\n</li>\n</ul>\n<h3>3) 优雅实现探讨</h3>\n<p>针对上面的问题，我们将问题逐个抽象，可以发现更优雅的实现方法。</p>\n<ul>\n<li>问题 1：如何对流数据同时进行读写</li>\n</ul>\n<p>针对流式数据的读写(一边返回一边缓存)，如下图所示，其实需要的不过是把 response.Body(io.Reader) 转换成一个 io.Reader 和一个 io.Writer。或者说是一个 io.Reader 和 io.Writer 合成一个 io.Reader。这很容易就联想到 Linux 里面的 Tee 命令。\n<img src=\"../img/blog_img/responsebody_write.png\" alt=\"image\"></p>\n<p>而在 Golang 中 Tee 命令是实现就是 io.TeeReader，那问题 1 的伪代码如下:</p>\n<pre><code>func HandleResponse(rw http.ResponseWriter, resp *http.Response) {\n        // create TeeReader with response.Body and cacher\n        newRespBody := io.TeeReader(resp.Body, cacher)\n\n        // client reads data from response\n        io.Copy(rw, newRespBody)\n}\n</code></pre>\n<p>通过 TeeReader 的对 Response.Body 和 Cacher 的整合，当请求 client 端从 response.Body 中读取数据时，将同时向 Cache 中写入返回数据，优雅的解决了流式数据的处理。</p>\n<ul>\n<li>问题 2：如何在缓存前先清洗流数据</li>\n</ul>\n<p>如下图所示，缓存前先清洗流数据，请求端和过滤端需要同时读取 response.Body（2 次读取问题）。也就是需要将 response.Body(io.Reader) 转换成两个 io.Reader。\n<img src=\"../img/blog_img/responseread.png\" alt=\"image\"></p>\n<p>也意味着问题 2 转化成：问题 1 中缓存端的 io.Writer 转换成 Data Filter 的 io.Reader。其实在 Linux 命令中也能找到类似命令，就是管道。因此问题 2 的伪代码如下：</p>\n<pre><code>func HandleResponse(rw http.ResponseWriter, resp *http.Response) {\n        pr, pw := io.Pipe()\n        // create TeeReader with response.Body and Pipe writer\n        newRespBody := io.TeeReader(resp.Body, pw)\n        go func() {\n                // filter reads data from response \n                io.Copy(dataFilter, pr)\n        }\n\n        // client reads data from response\n        io.Copy(rw, newRespBody)\n}\n</code></pre>\n<p>通过 io.TeeReader 和 io.PiPe，当请求 client 端从 response.Body 中读取数据时，Filter 将同时从 Response 读取到数据，优雅的解决了流式数据的 2 次读取问题。</p>\n<h2>YurtHub实现</h2>\n<p>最后看一下 YurtHub 中相关实现，由于 Response.Body 为 io.ReadCloser，所以实现了 dualReadCloser。同时 YurtHub 可能也面临对 http.Request 的缓存，所以增加了 isRespBody 参数用于判定是否需要负责关闭 response.Body。</p>\n<pre><code>// https://github.com/openyurtio/openyurt/blob/master/pkg/yurthub/util/util.go#L156\n// NewDualReadCloser create an dualReadCloser object\nfunc NewDualReadCloser(rc io.ReadCloser, isRespBody bool) (io.ReadCloser, io.ReadCloser) {\n    pr, pw := io.Pipe()\n    dr := &amp;dualReadCloser{\n        rc:         rc,\n        pw:         pw,\n        isRespBody: isRespBody,\n    }\n\n    return dr, pr\n}\n\ntype dualReadCloser struct {\n    rc io.ReadCloser\n    pw *io.PipeWriter\n    // isRespBody shows rc(is.ReadCloser) is a response.Body\n    // or not(maybe a request.Body). if it is true(it's a response.Body),\n    // we should close the response body in Close func, else not,\n    // it(request body) will be closed by http request caller\n    isRespBody bool\n}\n\n// Read read data into p and write into pipe\nfunc (dr *dualReadCloser) Read(p []byte) (n int, err error) {\n    n, err = dr.rc.Read(p)\n    if n &gt; 0 {\n        if n, err := dr.pw.Write(p[:n]); err != nil {\n            klog.Errorf(&quot;dualReader: failed to write %v&quot;, err)\n            return n, err\n        }\n    }\n\n    return\n}\n\n// Close close two readers\nfunc (dr *dualReadCloser) Close() error {\n    errs := make([]error, 0)\n    if dr.isRespBody {\n        if err := dr.rc.Close(); err != nil {\n            errs = append(errs, err)\n        }\n    }\n\n    if err := dr.pw.Close(); err != nil {\n        errs = append(errs, err)\n    }\n\n    if len(errs) != 0 {\n        return fmt.Errorf(&quot;failed to close dualReader, %v&quot;, errs)\n    }\n\n    return nil\n}\n</code></pre>\n<p>在使用 dualReadCloser 时，可以在 httputil.NewSingleHostReverseProxy 的 modifyResponse() 方法中看到。代码如下：</p>\n<pre><code>// https://github.com/openyurtio/openyurt/blob/master/pkg/yurthub/proxy/remote/remote.go#L85\nfunc (rp *RemoteProxy) modifyResponse(resp *http.Response) error {rambohe-ch, 10 months ago: • hello openyurt\n            // 省略部分前置检查                                                          \n            rc, prc := util.NewDualReadCloser(resp.Body, true)\n            go func(ctx context.Context, prc io.ReadCloser, stopCh &lt;-chan struct{}) {\n                err := rp.cacheMgr.CacheResponse(ctx, prc, stopCh)\n                if err != nil &amp;&amp; err != io.EOF &amp;&amp; err != context.Canceled {\n                    klog.Errorf(&quot;%s response cache ended with error, %v&quot;, util.ReqString(req), err)\n                }\n            }(ctx, prc, rp.stopCh)\n\n            resp.Body = rc\n}\n</code></pre>\n<h2>总结</h2>\n<p>OpenYurt 于 2020 年 9 月进入 CNCF 沙箱后，持续保持了快速发展和迭代，在社区同学一起努力下，目前已经开源的能力有：</p>\n<ul>\n<li>边缘自治</li>\n<li>边缘单元化管理</li>\n<li>云边协同运维</li>\n<li>一键式无缝转换能力</li>\n</ul>\n<p><a href=\"https://mp.weixin.qq.com/s/vdFrCDiIhPLVbOnf6vRxEw\">原文链接</a></p>\n",
  "link": "/zh-cn/blog/Elegant_realization_of_edge_gateway_caching_capabilities.html",
  "meta": {}
}