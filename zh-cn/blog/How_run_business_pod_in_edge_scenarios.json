{
  "filename": "How_run_business_pod_in_edge_scenarios.md",
  "__html": "<h1>OpenYurt：在边缘场景无缝运行使用InClusterConfig的业务Pod</h1>\n<p><strong>2021-10-15</strong>      <strong>新胜</strong></p>\n<h3>1.背景介绍</h3>\n<p>OpenYurt是业界首个非侵入的边缘计算云原生开源项目，通过边缘自治，云边协同，边缘单元化，边缘流量闭环等能力为用户提供云边一体化的使用体验。不少用户在使用OpenYurt的时候，经常需要把存量的使用InClusterConfig访问kube-apiserver的Pod通过OpenYurt迁移到边缘环境中。如下图所示：</p>\n<p><img src=\"../../img/InCluster1.png\" alt=\"\"></p>\n<p>在OpenYurt集群中，提供了使用InClusterConfig的业务Pod零修改就可以运行在边缘环境的能力。</p>\n<h3>2.面临挑战</h3>\n<p>使用InClusterConfig的业务Pod在边缘环境中运行，需要解决如下问题：</p>\n<ul>\n<li>\n<p>问题一：Pod通过InClusterConfig地址访问kube-apiserver，节点上默认网络规则（iptables/ipvs）将会把请求转发到kube-apiserver的PodIP，同时云端与边缘位于不同网络平面，边缘是无法访问到云端的PodIP。所以边缘业务Pod无法通过InClusterConfig访问到kube-apiserver。</p>\n<p><img src=\"../../img/Incluster2.png\" alt=\"Incluster2\"></p>\n</li>\n<li>\n<p>问题二：在解决问题一后，如果云边网络断开时业务Pod容器出现重启等状况，边缘Pod将无法从kube-apiserver获取到业务配置，这会影响到业务Pod的重启运行。</p>\n</li>\n</ul>\n<h3>3.解决方案</h3>\n<p>从上述问题可以看出，我们需要无感知的调整边缘pod的访问地址，同时需要在边缘环境中缓存业务配置，保证云边断网时也可以利用边缘缓存业务配置，保证云边断网时也可以利用边缘缓存来获取业务Pod的配置信息。具体解决方案如下；</p>\n<h5>3.1边缘Pod访问的云端endpoint优化</h5>\n<ul>\n<li>\n<p>Pod通过InClusterConfig访问kube-apiserver，源码如下：</p>\n<pre><code class=\"language-go\"><span class=\"hljs-function\"><span class=\"hljs-keyword\">func</span> <span class=\"hljs-title\">InClusterConfig</span><span class=\"hljs-params\">()</span> <span class=\"hljs-params\">(*Config, error)</span></span> {\n<span class=\"hljs-keyword\">const</span> (\n    tokenFile  = <span class=\"hljs-string\">\"/var/run/secrets/kubernetes.io/serviceaccount/token\"</span>\n    rootCAFile = <span class=\"hljs-string\">\"/var/run/secrets/kubernetes.io/serviceaccount/ca.crt\"</span>\n<span class=\"hljs-comment\">// 通过Kuberentes service对应的环境变量来获取访问地址</span>\nhost, port := os.Getenv(<span class=\"hljs-string\">\"KUBERNETES_SERVICE_HOST\"</span>), os.Getenv(<span class=\"hljs-string\">\"KUBERNETES_SERVICE_PORT\"</span>)\n<span class=\"hljs-keyword\">if</span> <span class=\"hljs-built_in\">len</span>(host) == <span class=\"hljs-number\">0</span> || <span class=\"hljs-built_in\">len</span>(port) == <span class=\"hljs-number\">0</span> {\n    <span class=\"hljs-keyword\">return</span> <span class=\"hljs-literal\">nil</span>, ErrNotInCluster\n}\n\n<span class=\"hljs-comment\">// skip some code...</span>\n\n<span class=\"hljs-keyword\">return</span> &amp;Config{\n    Host:            <span class=\"hljs-string\">\"https://\"</span> + net.JoinHostPort(host, port),\n    TLSClientConfig: tlsClientConfig,\n    BearerToken:     <span class=\"hljs-keyword\">string</span>(token),\n    BearerTokenFile: tokenFile,\n}, <span class=\"hljs-literal\">nil</span>\n}\n</code></pre>\n</li>\n<li>\n<p>因此想无感知调整边缘Pod访问的云端endpoint，只需要无侵入修改Pod的KUBERNETES_SERVICE_HOST和KUBERNETE_SERVICE_PORT两个环境变量或者修改kubernetes service地址。解决方案如下：</p>\n<ul>\n<li>\n<p>解决方案一：增加一个admission controller在边缘Pod创建时把kube-apiserver的公网地址自动注入到Pod的环境变量KUBERNETES_SERVICE_HOST和KUBERNETE_SERVICE_PORT</p>\n</li>\n<li>\n<p>解决方案二：边缘数据过滤框架中增加一个fillter yurthub的边缘数据过滤框架类似于admission controller ,专门用于边缘场景下在边缘应用无感知的状态下，无侵入的修改或者过滤云端返回的数据。目前支持的过滤器有：Masterservice，servicetopology，discardcloudservice等</p>\n</li>\n<li>\n<p>解决方案对比：</p>\n<table>\n<thead>\n<tr>\n<th style=\"text-align:center\"></th>\n<th style=\"text-align:center\">解决方案一</th>\n<th style=\"text-align:center\">解决方案二</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td style=\"text-align:center\">实现方案</td>\n<td style=\"text-align:center\">增加一个admission controller</td>\n<td style=\"text-align:center\">边缘数据过滤框架中增加一个filter</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">复杂度</td>\n<td style=\"text-align:center\">高（需要区别Pod运行在边缘还是云端）</td>\n<td style=\"text-align:center\">低</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">显示修改数据</td>\n<td style=\"text-align:center\">Pod中增加环境变量配置</td>\n<td style=\"text-align:center\">无</td>\n</tr>\n</tbody>\n</table>\n</li>\n</ul>\n</li>\n</ul>\n<p>综合实现复杂度，非侵入等设计理念，在OpenYurt中我们选择了解决方案二。如下图所示：</p>\n<p><img src=\"../../img/InCluster3.png\" alt=\"\"></p>\n<h5>3.2业务Pod的边缘自治</h5>\n<p>在云边网络断开状态下，业务Pod重启时，将无法从云端kube-apiserver获取到业务配置信息，因此需要在边缘本地缓存Pod的业务数据。</p>\n<p><img src=\"../../img/InCluster4.png\" alt=\"\"></p>\n<p>说明1：业务Pod通过yurthub访问kube-apiserver，也意味着[3.1 边缘Pod访问的云端endpoint优化]章节中提到的KUBERNETES_SERVICE_HOST和KUBERNETE_SERVICE_PORT环境变量被修改为yurthub https endpoint(169.254.2.1:10268)。</p>\n<p>说明2：如果业务Pod的大量list/watch操作导致大量本地cache，可能会造成本地磁盘压力，因此yurthub对业务Pod的缓存能力默认是关闭的，用户可以通过yurt-hub-cfg configmap的cache_agents字段中增加User-Agent信息来打开对应Pod的数据缓存。例如：</p>\n<pre><code class=\"language-go\">apiVersion: v1\nkind: ConfigMap\nmetadata:\n  name: yurt-hub-cfg\n  namespace: kube-system\ndata:\n  # 缓存边缘ingress-controller pod访问kube-apiserver的数据\n  cache_agents: <span class=\"hljs-string\">\"ingress-controller\"</span>\n</code></pre>\n<h3>4.总结</h3>\n<ul>\n<li>\n<p>如果存量Pod无需访问kube-apiserver或者InClusterConfig访问kube-apiserver，这些类型Pod可以零修改运行到OpenYurt集群的边缘环境上。通过其他方式访问kube-apiserver的业务Pod目前无法保证零修改运行到边缘环境。</p>\n</li>\n<li>\n<p>边缘业务Pod是否正常访问kube-apiserver，首先可以查看业务pod的环境变量是否正常：</p>\n<p>KUBERNETES_SERVICE_HOST=127.0.0.1或者169.254.2.1，KUBERNETES_SERVICE_PORT=10268。然后可以查看yurthub组件的日志是否有业务Pod相关的请求日志。当然也可以查询业务Pod的日志是否正常。最后可以确认/etc/kubernetes/cache目录是否有相关组件的缓存数据，如果没有可以再确认kube-system/yurt-hub-cfg configmap是否已经配置。</p>\n</li>\n<li>\n<p>使用InClusterConfig的Pod零修改运行到边缘环境的能力，整体实现由yurthub组件承载，没有给OpenYurt架构增加额外的负担，同时用户在使用过程中对该能力也基本无感知，对原生业务Pod无侵入。</p>\n</li>\n</ul>\n<h3>参考链接：</h3>\n<p>1.<a href=\"https://kubernetes.io/docs/tasks/access-application-cluster/access-cluster/#accessing-the-api-from-a-pod\">Accessing the API from a Pod</a></p>\n<p>2.<a href=\"https://github.com/openyurtio/openyurt/blob/master/docs/proposals/20210720-data-filtering-framework.md\">data filtering framework on the edge</a></p>\n<p>3.<a href=\"https://mp.weixin.qq.com/s/4BLfvMJJA623ZwRSgUE69A\">深度解读OpenYurt：边缘自治能力设计解析</a></p>\n",
  "link": "/zh-cn/blog/How_run_business_pod_in_edge_scenarios.html",
  "meta": {}
}